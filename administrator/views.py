from django.shortcuts import render

# Create your views here.
from rest_framework import generics, mixins
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from administrator.serializers import ProductSerializer, LinkSerializer, OrderSerializer
from common.authentication import JWTAuthentication
from common.serializers import UserSerializer
from core.models import User, Product, Link, Order
from django.core.cache import cache


class AmbassadorAPIView(APIView):
    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, _):
        ambassadors = User.objects.filter(is_ambassador=True)
        serializer = UserSerializer(ambassadors, many=True)
        return Response(serializer.data)


# Here we create the CRUD operations for the products
class ProductGenericAPIView(generics.GenericAPIView,
                            mixins.RetrieveModelMixin,
                            mixins.ListModelMixin,
                            mixins.CreateModelMixin,
                            mixins.UpdateModelMixin,
                            mixins.DestroyModelMixin
                            ):

    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def get(self, request, pk=None):
        if pk:
            # By extending the mixins we are able to use a retrive method to retrieve objects in our DB
            return self.retrieve(request, pk)
        # Pk is essentially a part of the URL that identified the primary key of the object in our db. If pk is not
        # provided then we simply get all the objects. Thanks to the mixin we can call "list" on self making this
        # operation super simple. Same goes for all CRUD operations.
        return self.list(request)

    # For the following 3 create, update, delete API's we delete the cache so that other endpoings that use
    # the products for it's data don't have stale data that's been cached.
    # However - for sake of practice that frontend cannot be cleared the same way we clear the backend cache.
    # This is because the frontend is being cached using a decorator. To see the key names of the frontend do
    # docker-compose exec redis sh
    # redis-cli
    # KEYS *
    # Here you will see the string names of the keys that are generated by the decorator way of caching.
    def post(self, request):
        response = self.create(request)

        for key in cache.keys('*'):
            if 'products_frontend' in key:
                cache.delete(key)
        cache.delete('products_backend')

        return response

    def put(self, request, pk=None):
        response = self.partial_update(request, pk)

        for key in cache.keys('*'):
            if 'products_frontend' in key:
                cache.delete(key)
        cache.delete('products_backend')

        return response

    def delete(self, request, pk=None):
        response = self.destroy(request, pk)

        for key in cache.keys('*'):
            if 'products_frontend' in key:
                cache.delete(key)

        cache.delete('products_backend')

        return response

# The Link API view is essentially only capable of creating a link which helps relate information to each other.
# A link, when created allows us to group an order, to a user, to 1 or more products contained in that order
#
class LinkAPIView(APIView):
    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request, pk=None):
        links = Link.objects.filter(user_id=pk)
        serializer = LinkSerializer(links, many=True)
        return Response(serializer.data)


# Under our models we have a one to many relationship from Order to OrderItems. In other worked a single Order
# can have 1 one or more Order Items. This view will retrieve an order which whos completed field is true. In
# context of operations this mean the order has been paid for.
class OrderAPIView(APIView):

    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request):
        orders = Order.objects.filter(complete=True)
        serializer = OrderSerializer(orders, many=True)
        return Response(serializer.data)
